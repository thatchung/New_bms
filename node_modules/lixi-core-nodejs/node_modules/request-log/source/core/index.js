const Elasticsearch = require('elasticsearch');
const Logger = require('./logger');

module.exports = class Request {
    static validateConnection() {
        this.client.ping({
            requestTimeout: 10000
        }, function (error) {
            if (error) {
                console.trace('[error]: axios_log connect error!', error);
            } else {
                this.logger.log('[info]: axios_log connect success');
            }
        });

        // create collection if needed
    }

    static get clientConfig() {
        const result = {};
        const connection = this.config.connection;
        result.host = connection.host;
        result.log = connection.log;
        if (connection.port) {
            result.host = `${connection.host}:${connection.port}`;
        }
        return result;
    }

    static get logger() {
        return this._logger;
    }

    static get client() {
        const client = new Elasticsearch.Client(this.clientConfig);
        return client;
    }

    static async setup({ connection, serviceName, requestKey, filter, customResponse, enable = true, canLog = false }) {
        const index = serviceName;

        this._logger = new Logger({ canLog });
        this._enable = enable;

        if (serviceName.trim() === "") {
            throw new Error('missing service name');
        }

        this.config = {
            connection,
            serviceName,
            requestKey,
            requestKey: 'X-Request-ID',
            filter: filter,
            customResponse: customResponse,
        };

        // await this.validateConnection();

        const isExist = await this.client.indices.exists({
            index: index,
        });
        if (isExist) {
            this.logger.log('[info]: index already exist');
        } else {
            this.logger.log('[info]: start create new index');
            let data = {
                index: index,
                body: {
                    mappings: {
                        properties: {
                            id: { type: 'keyword' },
                            client_name: { type: 'keyword' },
                            url: { type: 'keyword' },
                            custom_url: { type: 'keyword' },
                            method: { type: 'keyword' },
                            protocol: { type: 'keyword' },
                            host: { type: 'keyword' },
                            pathname: { type: 'keyword' },
                            curl: { type: 'keyword' },
                            request_time: { type: 'date' },
                            response_time: { type: 'date' },
                            process_time: { type: 'long' },
                            http_code: { type: 'integer' },
                            response_data: { type: 'keyword' },
                            response_header: { type: 'keyword' },
                            http_text: { type: 'keyword' },
                        },
                    },
                },
            };
            await this.client.indices.create(data);
            this.logger.log('[info]: create new index success');
        }
    }

    static async write({ index, id, data }) {
        try {
            //region [write new log]
            let result = await this.client.index({
                index: index,
                id: id,
                body: data,
            });
            return result;
        } catch(e) {
            this.logger.log(e);
        }
    }

    static async update({ index, id, data }) {
        let content = {
            index: index,
            id: id,
            body: {
                doc: data,
            },
        };

        const result = await this.client.update(content);
        return result;
    }
};