const Request = require('../core');
const Req2Curl = require('../core/req2curl');
const Elasticsearch = require('elasticsearch');
const Logger = require('../core/logger');
const ReqHelper = require('../core/req-helper');

class Custom extends Request {
    validateConnection() {
        this.client.ping({
            requestTimeout: 10000
        }, function (error) {
            if (error) {
                this.logger.trace('[error]: axios_log connect error!', error);
            } else {
                this.logger.log('[info]: axios_log connect success');
            }
        });

        // create collection if needed
    }

    get logger() {
        return this._logger;
    }

    get clientConfig() {
        const result = {};
        const connection = this.config.connection;
        result.host = connection.host;
        result.log = connection.log;
        if (connection.port) {
            result.host = `${connection.host}:${connection.port}`;
        }
        return result;
    }

    get client() {
        const client = new Elasticsearch.Client(this.clientConfig);
        return client;
    }

    async setup({ enable, connection, serviceName, requestKey, filter, customResponse, canLog = false }) {
        const index = serviceName;
        this._enable = enable === true || false;
        if (!this._enable) {
            return;
        }

        if (serviceName.trim() === "") {
            throw new Error('missing service name');
        }

        this.config = {
            connection,
            canLog,
            serviceName,
            requestKey: 'X-Request-ID',
            filter: filter,
            customResponse: customResponse,
        };
        this._logger = new Logger({ canLog });

        // await this.validateConnection();

        const isExist = await this.client.indices.exists({
            index: index,
        });
        if (isExist) {
            this.logger.log('[info]: index already exist');
        } else {
            this.logger.log('[info]: start create new index');
            let data = {
                index: index,
                body: {
                    mappings: {
                        properties: {
                            id: { type: 'keyword' },
                            client_name: { type: 'keyword' },
                            url: { type: 'keyword' },
                            custom_url: { type: 'keyword' },
                            method: { type: 'keyword' },
                            protocol: { type: 'keyword' },
                            host: { type: 'keyword' },
                            pathname: { type: 'keyword' },
                            curl: { type: 'keyword' },
                            request_time: { type: 'date' },
                            response_time: { type: 'date' },
                            process_time: { type: 'long' },
                            http_code: { type: 'integer' },
                            response_data: { type: 'keyword' },
                            response_header: { type: 'keyword' },
                            http_text: { type: 'keyword' },
                            error_message: { type: 'keyword' },
                        },
                    },
                },
            };
            await this.client.indices.create(data);
            this.logger.log('[info]: create new index success');
        }
    }

    async writeReq({ id, client_name, req, merge = {} }) {
        if (this._enable !== true) {
            return { request_time: 0 };
        }

        const data = Object.assign(ReqHelper.parse(req), merge);
        data.id = id;
        data.client_name = client_name;

        const keys = ['id', 'client_name', 'url', 'method', 'host', 'request_time'];
        for (let key of keys) {
            if (!data[key]) {
                this.logger.error(`[error]: missing require write data [${key}]`);
                return;
            }
        }

        if (!data.custom_url) {
            data.custom_url = `${data.method} ${data.url}`;
        }

        try {
            //region [write new log]
            let result = await this.client.index({
                index: this.config.serviceName,
                id: data.id,
                body: data,
            });
            return data;
        } catch (e) {
            this.logger.log(e);
        }
    }

    async write({ id, data }) {
        if (this._enable !== true) {
            return { request_time: 0 };
        }
        
        data.id = id;

        const keys = ['id', 'client_name', 'url', 'method', 'host', 'request_time'];
        for (let key of keys) {
            if (!data[key]) {
                this.logger.error(`[error]: missing require write data [${key}]`);
                return;
            }
        }

        if (!data.custom_url) {
            data.custom_url = `${data.method} ${data.url}`;
        }

        try {
            //region [write new log]
            let result = await this.client.index({
                index: this.config.serviceName,
                id: id,
                body: data,
            });
            return data;
        } catch (e) {
            this.logger.log(e);
        }
    }

    async update({ id, data }) {
        if (this._enable !== true) {
            return {};
        }

        data.id = id;

        const keys = ['id', 'response_time', 'process_time', 'http_code'];
        for (let key of keys) {
            if (!data[key]) {
                this.logger.error(`[error]: missing require write data [${key}]`);
                return;
            }
        }

        let content = {
            index: this.config.serviceName,
            id: id,
            body: {
                doc: data,
            },
        };

        const result = await this.client.update(content);
        return result;
    }
}

module.exports = Custom;