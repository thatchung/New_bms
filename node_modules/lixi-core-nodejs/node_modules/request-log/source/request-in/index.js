const AxiosDebug = require('axios-debug-log');
const Moment = require('moment');
const Request = require('../core');
const Req2Curl = require('./req2curl');

class RequestIn extends Request {
    static async setup(config) {
        try {
            AxiosDebug({
                request: this.request,
                response: this.response,
                error: this.error,
            });

            super.setup({ 
                connection: config.connection, 
                serviceName: `${config.service_name}_request_in`,
                filter: config.filter,
                customResponse: config.customResponse,
                enable: config.enable === true || false,
            });
        } catch(e) {
            console.log('[error]: ', e);
        }
    }

    static async before(req, res, next) {
        if (RequestIn._enable !== true) {
            next();
            return null;
        }
        
        try {
            const id = req.headers[RequestIn.config.requestKey] || Moment().valueOf();
            //write to elastic
            const url = req.url;
            const method = req.method.toLowerCase();
            const protocol = req.protocol.toLowerCase();
            const host = req.hostname.toLowerCase();
            const pathname = req.path.toLowerCase();
            const customUrl =  `${method} ${protocol}//${host}:${req.socket.localPort}${pathname}`;
            const curl = Req2Curl(req);
            const requestTime = Moment().valueOf();

            let canLog = true;

            if (typeof RequestIn.config.filter === "function") {
                canLog = await RequestIn.config.filter({ 
                    req, 
                    res,
                    host, 
                    method, 
                    url, 
                    curl 
                });
            }

            if (canLog === false) {
                return;
            }

            const data = {
                url,
                method,
                protocol,
                host,
                pathname,
                custom_url: customUrl,
                curl,
                request_time: requestTime,
            };

            var send = res.send;
            res.send = function (string) {
                res.locals.__requestLog = Object.assign(data, {
                    id,
                    response_data: string,
                });
                send.call(this, string);
            };
        } catch(e) {
            console.log('[error]: ', e);
        } finally {
            next();
        }
    }

    static async after(req, res, next) {
        if (RequestIn._enable !== true) {
            next();
            return null;
        }
        try {
            // prepare data for content log
            const beforeData = res.locals.__requestLog;
            let canLog = true;
            const id = beforeData.id;
            const responseData = beforeData.response_data;
            const responseHeader = res._header;
            const httpCode = res.statusCode;
            const httpText = res.statusMessage;
            const responseTime = Moment().valueOf();
            let processTime = null;
            if (beforeData.request_time) {
                processTime = responseTime - beforeData.request_time;
            }

            let content = {
                response_data: responseData,
                response_header: responseHeader,
                http_code: httpCode,
                http_text: httpText,
                response_time: responseTime,
                process_time: processTime,
            };

            const parameter = Object.assign({}, beforeData, content);

            // filter request canLog or not
            if (typeof RequestIn.config.filter === "function") {
                canLog = await RequestIn.config.filter(parameter);
            }
            if (canLog === false || !id) {
                return;
            }

            if (typeof RequestIn.config.customResponse === "function") {
                // update content log base on custom response
                content = await RequestIn.config.customResponse(parameter, { req, res });
            } else {
                // merge content log with before data
                Object.assign(content, beforeData);
            }

            RequestIn.write({
                index: RequestIn.config.serviceName,
                id,
                data: content,
            });
        } catch(e) {
            console.log('[error]: ', e);
        } finally {
            next();
        }
    }
}

module.exports = RequestIn;