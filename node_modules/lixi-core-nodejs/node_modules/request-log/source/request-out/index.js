const AxiosDebug = require('axios-debug-log');
const Moment = require('moment');
const Request = require('../core');
const URL = require('url').URL;
const ReqHelper = require('../core/req-helper');

class RequestOut extends Request {
    static async setup(config) {
        try {
            if (config.enable) {
                AxiosDebug({
                    request: this.request,
                    response: this.response,
                    error: this.error,
                });
    
                await super.setup({ 
                    connection: config.connection, 
                    serviceName: `${config.service_name}_request_out`,
                    filter: config.filter,
                    customResponse: config.customResponse,
                    enable: config.config,
                });
            }
        } catch (e) {
            
        }
    }

    static curl({ req }) {
        const _CurlHelper = require('../core/curlHelper');
        const curl = new _CurlHelper(req);
        const curlString = curl.generateCommand();
        
        return curlString;
    }

    static async request(debug, config) {
        if (RequestOut._enable === false) {
            return;
        }
        try {
            
            const id = config.headers[RequestOut.config.requestKey] || Moment().valueOf();
            if (!config.url && config.baseURL) {
                config.url = config.baseURL
            }

            const curl = RequestOut.curl({ req: config });
            const requestTime = Moment().valueOf();

            const method = config.method.toLowerCase();
            const url = new URL(config.url);
            const { host, protocol, pathname } = url;
            const customUrl = `${method} ${protocol}//${host}${pathname}`;
            let canLog = true;

            if (typeof RequestOut.config.filter === "function") {
                canLog = await RequestOut.config.filter({ 
                    _debug: debug, 
                    _config: config,
                    host, 
                    method, 
                    url, 
                    curl 
                });
            }
            if (canLog !== true) {
                return;
            }

            //save data for response object
            config.customId = id;
            config._custom = {
                id,
                url: url.toString(),
                method,
                protocol,
                host,
                pathname,
                custom_url: customUrl,
                curl,
                request_time: requestTime,
            };
        } catch(e) {
            RequestOut.logger.log(e);
        }
    }

    static async response(debug, response) {
        try {
            if (response.config.canLog === false) {
                return;
            }

            const id = response.config.customId;
            const beforeData = response.config._custom;
            const curl = RequestOut.curl({ req: response.config });

            const method = response.request.method.toLowerCase();
            const url = response.config.url;
            const { host, protocol, pathname } = url;
            const customUrl = `${method} ${protocol}//${host}${pathname}`;

            let responseData = response.data;
            if (typeof responseData !== 'string') {
                responseData = JSON.stringify(response.data);
            }
            const responseHeader = JSON.stringify(response.headers);
            const httpCode = response.status;
            const httpText = response.statusText;
            const responseTime = Moment().valueOf();

            let content = {
                response_data: responseData,
                response_header: responseHeader,
                http_code: httpCode,
                http_text: httpText,
                response_time: responseTime,
                method: response.request.method,
                url: url,
                host: response.request._headers.host,
                custom_url: customUrl,
                protocol: protocol,
                pathname: pathname,
                curl: curl,
            };

            if (response.headers.date) {
                content['process_time'] = responseTime - Moment(response.headers.date).valueOf();
            }

            Object.assign(content, beforeData);

            if (typeof RequestOut.config.customResponse === "function") {
                content = await RequestOut.config.customResponse(content);
            }

            const result = await RequestOut.write({
                index: RequestOut.config.serviceName,
                id: id,
                data: content,
            });
            return result;
        } catch(e) {
            RequestOut.logger.log(e);
        }
    }

    static async error(debug, error) {
        RequestOut.logger.log(arguments);
        const beforeData = error.config._custom;

        let content = {};
        if (error.response) {
            const responseTime = Moment().valueOf();
            const processTime = responseTime - beforeData['request_time'];
            content = {
                response_data: JSON.stringify(error.response.data),
                response_header: JSON.stringify(error.response.headers),
                http_code: error.response.status,
                http_text: error.response.statusText,
                response_time: responseTime,
                process_time: processTime,
            };
        }
        Object.assign(content, beforeData);
        if (typeof RequestOut.config.customResponse === "function") {
            content = await RequestOut.config.customResponse(content);
        }

        const result = await RequestOut.write({
            index: RequestOut.config.serviceName,
            id: content.id,
            data: content,
        });
        return result;
    }
}

module.exports = RequestOut;